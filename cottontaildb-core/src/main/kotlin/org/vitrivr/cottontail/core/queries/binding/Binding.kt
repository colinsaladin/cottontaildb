package org.vitrivr.cottontail.core.queries.binding

import org.vitrivr.cottontail.core.database.ColumnDef
import org.vitrivr.cottontail.core.queries.Digest
import org.vitrivr.cottontail.core.queries.Node
import org.vitrivr.cottontail.core.queries.planning.cost.Cost
import org.vitrivr.cottontail.core.values.types.Types
import org.vitrivr.cottontail.core.values.types.Value

/**
 * This class acts as a level of indirection for [Value]'s used during query planning, optimization and execution.
 *
 * @author Ralph Gasser
 * @version 1.3.0
 */
sealed interface Binding: Node {

    /** The [Value]. */
    val value: Value?

    /** The [Types] held by this [Binding]. */
    val type: Types<*>

    /** Flag indicating whether [Binding] remains static in the context of a query. */
    val static: Boolean

    /** The [BindingContext] associated with this [Binding]. */
    val context: BindingContext

    /**
     * Copies this [Binding], creating a new [Binding] that is initially bound to the same [BindingContext].
     *
     * @return Copy of this [Binding]
     */
    override fun copy(): Binding

    /** A [Binding] for a literal [Value] without any indirection other than the [Binding] itself. */
    data class Literal(val bindingIndex: Int, override val type: Types<*>, override var context: BindingContext): Binding {
        override val value: Value?
            get() = this.context[this]
        override val static: Boolean
            get() = true
        override val cost: Cost
            get() = Cost.MEMORY_ACCESS
        override fun copy() = Literal(this.bindingIndex, this.type, this.context)
        override fun digest(): Digest= this.hashCode().toLong()
        override fun bind(context: BindingContext) {
            this.context = context
        }
        fun update(value: Value?) = this.context.update(this, value)
        override fun toString(): String = ":$bindingIndex"
    }

    /** A [Binding] for a value referred to by a [ColumnDef]. Can only be accessed during query execution. */
    data class Column(val column: ColumnDef<*>, override var context: BindingContext): Binding {
        override val value: Value?
            get() = this.context[this]
        override val type: Types<*>
            get() = this.column.type
        override val static: Boolean
            get() = false
        override val cost: Cost
            get() = Cost.MEMORY_ACCESS
        override fun copy() = Column(this.column, this.context)
        override fun digest(): Digest = this.hashCode().toLong()
        override fun bind(context: BindingContext) {
            this.context = context
        }
        override fun toString(): String = "${this.column.name}"
    }

    /** A [Binding] for a value generated by invocation of a [org.vitrivr.cottontail.core.queries.functions.Function]. */
    data class Function(val function: org.vitrivr.cottontail.core.queries.functions.Function<*>, val arguments: List<Binding>, override var context: BindingContext): Binding {

        init {
            this.function.signature.arguments.forEachIndexed {  i, arg ->
                check(arg.type == this.arguments[i].type) { "Type ${this.arguments[i].type} of argument $i is incompatible with function ${function.signature}." }
            }
        }

        override val value: Value?
            get() = this.context[this]
        override val type: Types<*>
            get() = this.function.signature.returnType
        override val cost: Cost
            get() = this.function.cost + this.arguments.map { it.cost }.reduce { c1, c2 -> c1 + c2}
        override val static: Boolean
            get() = false
        override fun copy() = Function(this.function, this.arguments.map { it.copy() }, this.context)
        override fun digest(): Digest = this.hashCode().toLong()
        override fun bind(context: BindingContext) {
            this.context = context
            this.arguments.forEach { it.bind(context) }
        }
        override fun toString(): String = "${this.function.signature}"

        /**
         * Tries to resolve all [ColumnDef] that are required by this [Binding.Function] and possible sub-functions.
         *
         * @return List of required [ColumnDef].
         */
        fun requiredColumns(): List<ColumnDef<*>> = this.arguments.flatMap {
            val columns = mutableSetOf<ColumnDef<*>>()
            when (it) {
                is Column -> columns.add(it.column)
                is Function -> columns.addAll(it.requiredColumns())
                else -> {}
            }
            columns.toList()
        }
    }
}